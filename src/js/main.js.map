{"version":3,"sources":["main.ts"],"names":["Transpiler","Transpiler.constructor","Transpiler.compile","Transpiler.callCompile","Transpiler.getCompilerOptions","Transpiler.createCompilerHost","Transpiler.prettyPrint","Transpiler.walk","Transpiler.walk.traverse","Transpiler.walk.report"],"mappings":"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","file":"main.js","sourcesContent":["///<reference path=\"../typings/node/node.d.ts\"/>\n///<reference path=\"../typings/typescript/typescript.d.ts\"/>\n\nimport ts = require('typescript');\nimport fs = require('fs'); // filesystem module\nimport util = require('util');\nimport path = require('path');\n\nvar HashMap = require('hashmap');\n\n/* TranspilerOptions Class will go here */\n\n/* The Transpiler Class */\nexport class Transpiler {\n\tprivate output: string; // for now, what is an output object?\n\tprivate currentFile: ts.SourceFile;\n\n\tmap = new HashMap();\n\tnodes: ts.Node[] = [];\n\n\t// last comment index?\n\tprivate errors: string[] = [];\n\n\t//private transpilers;\n\t// (Transpiler options here when I know what's needed) \n\n\tconstructor() {\n\t\t// will instantiate different transpilers; nothing here yet\n\n\t} \n\n\tcompile(fileNames: string[], options: ts.CompilerOptions): void {\n\t    var program = ts.createProgram(fileNames, options);\n\t    var emitResult = program.emit();\n\n\t    var allDiagnostics = ts.getPreEmitDiagnostics(program).concat(emitResult.diagnostics);\n\n\t    allDiagnostics.forEach(diagnostic => {\n\t        var loc = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);\n\t        var message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\\n');\n\t        console.log(\n\t        \t'${diagnostic.file.fileName} (${loc.line + 1},${loc.character + 1}): ${message}'\n\t        );\n\t    });\n\n\t    var exitCode = emitResult.emitSkipped ? 1 : 0;\n\t    console.log(\"Process exiting with code '${exitCode}'.\");\n\t    process.exit(exitCode);\n\t}\n\n\tcallCompile() {\n\t\tthis.compile(process.argv.slice(2), {\n\t\t\tnoEmitOnError: true, noImplicitAny: true,\n\t\t\ttarget: ts.ScriptTarget.ES5, module: ts.ModuleKind.CommonJS\n\t\t});\n\t}\n\n\t// return set options for the compiler\n\tgetCompilerOptions(): ts.CompilerOptions {\n\t\tconst options: ts.CompilerOptions = {\n\t\t\tallowNonTsExtensions: true,\n\t\t\tmodule: ts.ModuleKind.CommonJS,\n\t\t\ttarget: ts.ScriptTarget.ES6,\n\t\t};\n\t\treturn options;\n\t}\n\n\t/* Create a Transpiler Class */\n\tcreateCompilerHost(fileNames: string[], options?: ts.CompilerOptions): ts.CompilerHost {\n\t\t// why is this needed? rather, what is the point?\n\t\tvar fileMap: { [s: string]: boolean } = {};\n\t\tfileNames.forEach((f) => fileMap[f] = true); // why?\n\n\t\t// sanity check that given files actually exist\n\t\t// fileNames.forEach((fpath) => {\n\t\t// \tfs.exists(fpath, function(exists) {\n\t\t// \t\tconsole.log(exists ? \"exists\" : \"nope :(\");\n\t\t// \t});\n\t\t// });\n\n\t\t//console.log(process.cwd());\n\n\t\t// the methods of a compiler host object\n\t\treturn {\n\t\t\tgetSourceFile: (sourceName, languageVersion) => {\n\t\t\t\tif (fileMap.hasOwnProperty(sourceName)) {\n\t\t\t\t\tconsole.log('hello?');\n\t\t\t\t\tconsole.log(sourceName);\n\t\t\t\t\tvar contents = fs.readFileSync(sourceName, 'UTF-8');\n\t\t\t\t\tconsole.log(\"==========================================================\");\n\t\t\t\t\tconsole.log(contents);\n\t\t\t\t\tconsole.log(\"==========================================================\");\n\t\t\t\t\treturn ts.createSourceFile(sourceName, contents, \n\t\t\t\t\t\t\tthis.getCompilerOptions().target, true);\n\t\t\t\t} \n\t\t\t\tif (sourceName === \"lib.d.ts\")\n\t\t\t\t\treturn ts.createSourceFile(sourceName, '', this.getCompilerOptions().target, true);\n\t\t\t\treturn undefined;\n\t\t\t},\n\t\t\t// these are not used; just exist to satisfy interface?\n\t\t\twriteFile: function(name, text, writeByteOrderMark, outputs) {\n\t\t\t\tfs.writeFile(name, text);\n\t\t\t},\n\t\t\tgetDefaultLibFileName: function() { return \"lib.d.ts\"; },\n\t\t\tuseCaseSensitiveFileNames: function() { return true; },\n\t\t\tgetCanonicalFileName: function(filename) { return filename; },\n\t\t\tgetCurrentDirectory: function() { return \"\"; },\n\t\t\tgetNewLine: function() { return \"\\n\"; }\n\t\t};\n\t}\n\n\t/* For later? Do I even need this though. */\n\tprettyPrint() {\n\t}\n\n\t/* Walk the AST of the program */\n\twalk(sourcefile: ts.SourceFile, program: ts.Program) {\n\t\tvar typeChecker = program.getTypeChecker();\n\n\t\t//console.log(typeChecker.getTypeAtLocation(sourcefile));\n\n\t\ttraverse(sourcefile, typeChecker);\n\n\t\tfunction traverse(node: ts.Node, typeChecker, count?: number) {\n\n\t\t\tswitch (node.kind) {\n\t\t\t\tcase ts.SyntaxKind.PropertyAssignment:\n\t\t\t\t\tconsole.log('PropertyAssignment');\n\t\t\t\t\tbreak;\n\t\t\t\tcase ts.SyntaxKind.PropertyDeclaration:\n\t\t\t\t\tconsole.log('PropertyDeclaration');\n\t\t\t\t\tbreak;\n\t\t\t\tcase ts.SyntaxKind.ShorthandPropertyAssignment:\n\t\t\t\t\tconsole.log('ShorthandPropertyAssignment');\n\t\t\t\t\tbreak;\n\t\t\t\tcase ts.SyntaxKind.BinaryExpression:\n\t\t\t\t\t//console.log('BinaryExpression');\n\t\t\t\t\tvar binExpr = <ts.BinaryExpression>node;\n\t\t\t\t\t//console.log(binExpr);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ts.SyntaxKind.Identifier:\n\t\t\t\t\tvar ident = <ts.Identifier>node;\n\t\t\t\t\t//console.log(typeChecker.getTypeAtLocation(ident));\n\t\t\t\t\tbreak;\n\t\t\t\tcase ts.SyntaxKind.DotToken:\n\t\t\t\t\tconsole.log(\"dot token, do nothing\");\n\t\t\t\t\tbreak;\n\t\t\t\t// PAE has: \n\t\t\t\t// 1. expression: LeftHandSideExpression\n\t\t\t\t// 2. dotToken: Node\n\t\t\t\t// 3. name: Identifier (right hand side of expression)\n\t\t\t\tcase ts.SyntaxKind.PropertyAccessExpression:\n\t\t\t\t\tvar pae = <ts.PropertyAccessExpression>node; // is this casting?\n\t\t\t\t\tconsole.log('PropertyAccessExpression');\n\t\t\t\t\tconsole.log(\"========================================================\");\n\t\t\t\t\tconsole.log(pae);\n\n\t\t\t\t\t//console.log(pae.expression + \": \" + typeChecker.typeToString(\n\t\t\t\t\t//\ttypeChecker.getTypeAtLocation(pae.expression)));\n\t\t\t\t\t//console.log(pae.name + \": \" + typeChecker.typeToString(\n\t\t\t\t\t//\ttypeChecker.getTypeAtLocation(pae.name)));\n\n\t\t\t\t\t//console.log(pae.expression.text); // doesn't have it but it prints? I don't get it.\n\n\n\t\t\t\t\t// this.map.set(pae.expression.text, { });\n\t\t\t\t\t\n\t\t\t\t\tconsole.log(\"========================================================\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tts.forEachChild(node, function(node) {\n\t\t\t\ttraverse(node, typeChecker, count);\n\t\t\t});\n\t\t}\n\n\t\t/* Report information when necessary */\n\t\tfunction report(node: ts.Node, message: string) {\n\t\t\tvar lc = sourcefile.getLineAndCharacterOfPosition(node.getStart());\n        \tconsole.log('${sourcefile.fileName} (${lc.line + 1},${lc.character + 1}): ${message}');\n\t\t}\n\t}\n}\n\nvar transpiler = new Transpiler();\nvar host = transpiler.createCompilerHost(['../../test/hello.ts']);\nconsole.log('created compiler host');\nvar source : ts.SourceFile = host.getSourceFile('../../test/hello.ts', ts.ScriptTarget.ES6);\n\n// to create the program, the host calls getSourceFile IF you pass in a host. It's an optional parameter\nvar program : ts.Program = ts.createProgram(['../../test/hello.ts'], transpiler.getCompilerOptions());\ntranspiler.walk(source, program);\n"],"sourceRoot":"/source/"}